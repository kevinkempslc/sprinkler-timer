/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "SprinklerServer_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SprinklerServerThrift {

int _kRunStateValues[] = {
  RunState::RS_AUTO,
  RunState::RS_MANUAL,
  RunState::RS_RAIN,
  RunState::RS_OFF
};
const char* _kRunStateNames[] = {
  "RS_AUTO",
  "RS_MANUAL",
  "RS_RAIN",
  "RS_OFF"
};
const std::map<int, const char*> _RunState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRunStateValues, _kRunStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDayValues[] = {
  Day::SUNDAY,
  Day::MONDAY,
  Day::TUESDAY,
  Day::WEDNESDAY,
  Day::THURSDAY,
  Day::FRIDAY,
  Day::SATURDAY
};
const char* _kDayNames[] = {
  "SUNDAY",
  "MONDAY",
  "TUESDAY",
  "WEDNESDAY",
  "THURSDAY",
  "FRIDAY",
  "SATURDAY"
};
const std::map<int, const char*> _Day_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kDayValues, _kDayNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kProgramModeValues[] = {
  ProgramMode::DAY_OF_WEEK,
  ProgramMode::EVEN_DAYS,
  ProgramMode::ODD_DAYS,
  ProgramMode::DAY_INTERVAL
};
const char* _kProgramModeNames[] = {
  "DAY_OF_WEEK",
  "EVEN_DAYS",
  "ODD_DAYS",
  "DAY_INTERVAL"
};
const std::map<int, const char*> _ProgramMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kProgramModeValues, _kProgramModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Zone::~Zone() throw() {
}


void Zone::__set_number(const int32_t val) {
  this->number = val;
}

void Zone::__set_duration(const int32_t val) {
  this->duration = val;
}

void Zone::__set_name(const std::string& val) {
  this->name = val;
}

void Zone::__set_enabledForCurrentProgram(const bool val) {
  this->enabledForCurrentProgram = val;
}

uint32_t Zone::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->number);
          this->__isset.number = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->duration);
          this->__isset.duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabledForCurrentProgram);
          this->__isset.enabledForCurrentProgram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Zone::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Zone");

  xfer += oprot->writeFieldBegin("number", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->number);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->duration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabledForCurrentProgram", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->enabledForCurrentProgram);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Zone &a, Zone &b) {
  using ::std::swap;
  swap(a.number, b.number);
  swap(a.duration, b.duration);
  swap(a.name, b.name);
  swap(a.enabledForCurrentProgram, b.enabledForCurrentProgram);
  swap(a.__isset, b.__isset);
}

Zone::Zone(const Zone& other0) {
  number = other0.number;
  duration = other0.duration;
  name = other0.name;
  enabledForCurrentProgram = other0.enabledForCurrentProgram;
  __isset = other0.__isset;
}
Zone& Zone::operator=(const Zone& other1) {
  number = other1.number;
  duration = other1.duration;
  name = other1.name;
  enabledForCurrentProgram = other1.enabledForCurrentProgram;
  __isset = other1.__isset;
  return *this;
}
void Zone::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Zone(";
  out << "number=" << to_string(number);
  out << ", " << "duration=" << to_string(duration);
  out << ", " << "name=" << to_string(name);
  out << ", " << "enabledForCurrentProgram=" << to_string(enabledForCurrentProgram);
  out << ")";
}


BulkData::~BulkData() throw() {
}


void BulkData::__set_runState(const RunState::type val) {
  this->runState = val;
}

void BulkData::__set_startTimeOverlap(const bool val) {
  this->startTimeOverlap = val;
}

void BulkData::__set_currentProgram(const int32_t val) {
  this->currentProgram = val;
}

void BulkData::__set_startHour(const int32_t val) {
  this->startHour = val;
}

void BulkData::__set_startMin(const int32_t val) {
  this->startMin = val;
}

void BulkData::__set_programMode(const ProgramMode::type val) {
  this->programMode = val;
}

void BulkData::__set_programInterval(const int32_t val) {
  this->programInterval = val;
}

void BulkData::__set_programDays(const std::vector<Day::type> & val) {
  this->programDays = val;
}

void BulkData::__set_programZones(const std::vector<Zone> & val) {
  this->programZones = val;
}

uint32_t BulkData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->runState = (RunState::type)ecast2;
          this->__isset.runState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startTimeOverlap);
          this->__isset.startTimeOverlap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->currentProgram);
          this->__isset.currentProgram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startHour);
          this->__isset.startHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startMin);
          this->__isset.startMin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->programMode = (ProgramMode::type)ecast3;
          this->__isset.programMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->programInterval);
          this->__isset.programInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->programDays.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->programDays.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              int32_t ecast9;
              xfer += iprot->readI32(ecast9);
              this->programDays[_i8] = (Day::type)ecast9;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.programDays = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->programZones.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->programZones.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->programZones[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.programZones = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulkData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulkData");

  xfer += oprot->writeFieldBegin("runState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->runState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTimeOverlap", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->startTimeOverlap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("currentProgram", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->currentProgram);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startHour", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->startHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startMin", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->startMin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("programMode", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->programMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("programInterval", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->programInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("programDays", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->programDays.size()));
    std::vector<Day::type> ::const_iterator _iter15;
    for (_iter15 = this->programDays.begin(); _iter15 != this->programDays.end(); ++_iter15)
    {
      xfer += oprot->writeI32((int32_t)(*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("programZones", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->programZones.size()));
    std::vector<Zone> ::const_iterator _iter16;
    for (_iter16 = this->programZones.begin(); _iter16 != this->programZones.end(); ++_iter16)
    {
      xfer += (*_iter16).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulkData &a, BulkData &b) {
  using ::std::swap;
  swap(a.runState, b.runState);
  swap(a.startTimeOverlap, b.startTimeOverlap);
  swap(a.currentProgram, b.currentProgram);
  swap(a.startHour, b.startHour);
  swap(a.startMin, b.startMin);
  swap(a.programMode, b.programMode);
  swap(a.programInterval, b.programInterval);
  swap(a.programDays, b.programDays);
  swap(a.programZones, b.programZones);
  swap(a.__isset, b.__isset);
}

BulkData::BulkData(const BulkData& other17) {
  runState = other17.runState;
  startTimeOverlap = other17.startTimeOverlap;
  currentProgram = other17.currentProgram;
  startHour = other17.startHour;
  startMin = other17.startMin;
  programMode = other17.programMode;
  programInterval = other17.programInterval;
  programDays = other17.programDays;
  programZones = other17.programZones;
  __isset = other17.__isset;
}
BulkData& BulkData::operator=(const BulkData& other18) {
  runState = other18.runState;
  startTimeOverlap = other18.startTimeOverlap;
  currentProgram = other18.currentProgram;
  startHour = other18.startHour;
  startMin = other18.startMin;
  programMode = other18.programMode;
  programInterval = other18.programInterval;
  programDays = other18.programDays;
  programZones = other18.programZones;
  __isset = other18.__isset;
  return *this;
}
void BulkData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulkData(";
  out << "runState=" << to_string(runState);
  out << ", " << "startTimeOverlap=" << to_string(startTimeOverlap);
  out << ", " << "currentProgram=" << to_string(currentProgram);
  out << ", " << "startHour=" << to_string(startHour);
  out << ", " << "startMin=" << to_string(startMin);
  out << ", " << "programMode=" << to_string(programMode);
  out << ", " << "programInterval=" << to_string(programInterval);
  out << ", " << "programDays=" << to_string(programDays);
  out << ", " << "programZones=" << to_string(programZones);
  out << ")";
}


UpdateData::~UpdateData() throw() {
}


void UpdateData::__set_hour(const int32_t val) {
  this->hour = val;
}

void UpdateData::__set_minute(const int32_t val) {
  this->minute = val;
}

void UpdateData::__set_activeProgram(const int32_t val) {
  this->activeProgram = val;
}

void UpdateData::__set_activeZone(const int32_t val) {
  this->activeZone = val;
}

void UpdateData::__set_manualProgram(const int32_t val) {
  this->manualProgram = val;
}

void UpdateData::__set_manualZone(const int32_t val) {
  this->manualZone = val;
}

void UpdateData::__set_runState(const RunState::type val) {
  this->runState = val;
}

void UpdateData::__set_startTimeOverlap(const bool val) {
  this->startTimeOverlap = val;
}

void UpdateData::__set_todaysPrograms(const std::vector<int32_t> & val) {
  this->todaysPrograms = val;
}

uint32_t UpdateData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->hour);
          this->__isset.hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minute);
          this->__isset.minute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->activeProgram);
          this->__isset.activeProgram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->activeZone);
          this->__isset.activeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->manualProgram);
          this->__isset.manualProgram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->manualZone);
          this->__isset.manualZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->runState = (RunState::type)ecast19;
          this->__isset.runState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->startTimeOverlap);
          this->__isset.startTimeOverlap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->todaysPrograms.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->todaysPrograms.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readI32(this->todaysPrograms[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.todaysPrograms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateData");

  xfer += oprot->writeFieldBegin("hour", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minute", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->minute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("activeProgram", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->activeProgram);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("activeZone", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->activeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manualProgram", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->manualProgram);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manualZone", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->manualZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("runState", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32((int32_t)this->runState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startTimeOverlap", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->startTimeOverlap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("todaysPrograms", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->todaysPrograms.size()));
    std::vector<int32_t> ::const_iterator _iter25;
    for (_iter25 = this->todaysPrograms.begin(); _iter25 != this->todaysPrograms.end(); ++_iter25)
    {
      xfer += oprot->writeI32((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateData &a, UpdateData &b) {
  using ::std::swap;
  swap(a.hour, b.hour);
  swap(a.minute, b.minute);
  swap(a.activeProgram, b.activeProgram);
  swap(a.activeZone, b.activeZone);
  swap(a.manualProgram, b.manualProgram);
  swap(a.manualZone, b.manualZone);
  swap(a.runState, b.runState);
  swap(a.startTimeOverlap, b.startTimeOverlap);
  swap(a.todaysPrograms, b.todaysPrograms);
  swap(a.__isset, b.__isset);
}

UpdateData::UpdateData(const UpdateData& other26) {
  hour = other26.hour;
  minute = other26.minute;
  activeProgram = other26.activeProgram;
  activeZone = other26.activeZone;
  manualProgram = other26.manualProgram;
  manualZone = other26.manualZone;
  runState = other26.runState;
  startTimeOverlap = other26.startTimeOverlap;
  todaysPrograms = other26.todaysPrograms;
  __isset = other26.__isset;
}
UpdateData& UpdateData::operator=(const UpdateData& other27) {
  hour = other27.hour;
  minute = other27.minute;
  activeProgram = other27.activeProgram;
  activeZone = other27.activeZone;
  manualProgram = other27.manualProgram;
  manualZone = other27.manualZone;
  runState = other27.runState;
  startTimeOverlap = other27.startTimeOverlap;
  todaysPrograms = other27.todaysPrograms;
  __isset = other27.__isset;
  return *this;
}
void UpdateData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateData(";
  out << "hour=" << to_string(hour);
  out << ", " << "minute=" << to_string(minute);
  out << ", " << "activeProgram=" << to_string(activeProgram);
  out << ", " << "activeZone=" << to_string(activeZone);
  out << ", " << "manualProgram=" << to_string(manualProgram);
  out << ", " << "manualZone=" << to_string(manualZone);
  out << ", " << "runState=" << to_string(runState);
  out << ", " << "startTimeOverlap=" << to_string(startTimeOverlap);
  out << ", " << "todaysPrograms=" << to_string(todaysPrograms);
  out << ")";
}

} // namespace
